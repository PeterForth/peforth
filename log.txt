
peforth

[x] 13:59 2017-07-31 找到 JavaScript eval() equivalent in Python
	https://stackoverflow.com/questions/701802/how-do-i-execute-a-string-containing-python-code-in-python
	成功了!!
	>>> mycode = 'print ("hello world")'
	>>> exec(mycode)
	hello world
	>>>

	The technique of returning a function from another function is known as currying:
	https://stackoverflow.com/questions/14261474/how-do-i-write-a-function-that-returns-another-function
	
	Python annoymous function lambda
	http://blog.csdn.net/majianfei1023/article/details/45269343
	https://www.zhihu.com/question/20125256
	
[x] review project-k , should project-k support python too? 
    which will be peforth.py 	

[x] 直接問 pyforth 的原作者的版權條件 ---> 用不著了.
[x] 實驗用 exec() 生成一個 function
		s = ''' 
		def show(s):
			print(s)
		'''
	exec(s)
	>>> show('abc')
	abc
	>>> 成功了!
	
[x]	Try to define an python object
	s = '''
	class a():
		vm = None
		def b(self):  # self is must
			print(b)  # b unknown
			print(self)
			print(a)
			vm = self
	c = a()
	'''
	exec(s)
[x] peforth 可以引用的讀檔範例
    # average5 .py 
    def main() : 
        fileName = input ("What file are the numbers in? " ) 
        infile = open (fileName, ' r ') 
        sum = 0 
        count = 0 
        for line in infile:
            sum = sum + eval (line) 
            count = count + 1 
        print ("\nThe average Of the numbers is", sum / count) 
    main ( ) 

    # average6.py 
    def main() : 
    fileName = input ("What file are the numbers in? " ) 
    infile = open ( fileName 
    sum = 0.0 
    count = 0 
    line = infile.readline()
    while line != "" 
        sum = sum + eval(line) 
        count = count + 1 
        line = infile.readline()
    print("\nThe average Of the numbers is", sum / count) 
    main()

[x] module 的用法搞懂了，很簡單。 peforth.py 就是 peforth VM.
    不需要像 javascript 用一個 function 把整個 vm 包起來, see 
    GitHub\peforth\projectile.py 
    python can redefine functions and methods. Function and methods are
    variables too.
    python objects, like javascript, can add properties and methods
    through simply assign a value to it.
        >>> type(show)  # show is an object
        <class 'projectile.Projectile'>
        >>> show
        <projectile.Projectile object at 0x000001C6260D0438>
        >>> show.x = 0   # assign new property to show
        >>> show.y = 11
        >>> show.p = 22
        >>> dir(show)    # check it out
        ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', 
        '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', 
        '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', 
        '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', 
        '__str__', '__subclasshook__', '__weakref__', 'getHere', 'getX', 'getY', 'p', 
        'update', 'x', 'xpos', 'xvel', 'y', 'ypos', 'yvel']
        >>>
[x] python 也可以 see function 的 source code
    https://stackoverflow.com/questions/427453/how-can-i-get-the-source-code-of-a-python-function
    
    def foo(a):
    x = 2 # how about a comment?
    return x + a

    import inspect

    # inspect.getsource(foo)
    # u'def foo(a):\n    x = 2\n    return x + a\n'

    print (inspect.getsource(foo))
    ==> 結果完全成功, 連 comment 也被顯示出來。
    
    同一篇 stackoverflow 介紹的 dis module 也真的可行!
    >>> import dis
    >>> def func(x):
    ...     print(x+1)
    ...
    >>> func(123)
    124
    >>> dis.dis(func)
      2           0 LOAD_GLOBAL              0 (print)
                  2 LOAD_FAST                0 (x)
                  4 LOAD_CONST               1 (1)
                  6 BINARY_ADD
                  8 CALL_FUNCTION            1
                 10 POP_TOP
                 12 LOAD_CONST               0 (None)
                 14 RETURN_VALUE
    >>>    哇! 顯示出 function 的機械碼, 太正點了!! 
    
[x] Python equivalent of:
    Word.prototype.toString = function(){return this.name + " " + this.help}; // every word introduces itself
    --> 有了, 就是去定義 __str__ prototype of the class

    #------- ex2.py ---------------
    class d():
        def __str__(self):
            return "a __str__"
        def __repr__(self):
            return "a __repr__"

    class x():
        name = 'stella'
        feet = 'splender'
    #------------------------------

    >>> import ex2
    >>> x = ex2.x()
    >>> x
    <ex2.x object at 0x00000170D77202B0>  <---- default __repr__ 打印
    >>> print(x)
    <ex2.x object at 0x00000170D77202B0> <---- default __str__ 傳回值

    >>> d = ex2.d()
    >>> d   # <--------- 執行該 obj 時, 打印 __repr__() 的傳回值
    a __repr__         # 應該讓它執行該 word
    >>> print(d)  # <---- obj 本身的傳回值是 __str__() 的傳回值
    a __str__
    >>>    
    
[x] 進一步刺探未來的 peforth.py kernel module 的特性   
    Ynote: 搞懂 python 的 module files globals() locals().note   

[x] docode() 要組裝 function 需參考 anonymous function 的定義方法:
    https://stackoverflow.com/questions/6629876/how-to-make-an-anonymous-function-in-python-without-christening-it
    Study built-in function exec() https://docs.python.org/3/library/functions.html#exec    
    Study build-in function compile() https://docs.python.org/3/library/functions.html#compile
    [ ] genxt() 有成功, 但是還有 bug 
        (Pdb) f = genxt("print('hello')")
        (Pdb) f()
        *** TypeError: xt() missing 1 required positional argument: '_me'
        (Pdb) f(None)
        hello
        (Pdb) 
        f = genxt('''print('hello')''')
    import sys
    sys.path.append('c:/Users/hcche/Documents/GitHub/peforth')
[x] 12:50 2017/08/12 已經跑起來了, debugging compiling == 'code' 的問題
    --> 可能是 end-code 裡面 Word(newname,newxt) 失敗的關係 --> no, it can't fail
    --> 應該是 docode 裡面, 結構不太好, 萬一 reDef 或 genxt() 失敗了會怎樣?
        很多都會半途結束, 留下 compiling == 'code' 的問題。 --> all tested, behavior acceptable now
[x] "import re" in peforth.py kernel is not a good choice.
    Simply letting the main program to do that. The main program is eforth.3py 
    --> Yeah! it works.
        c:\Users\hcche\Documents\GitHub\peforth>python eforth.3py
        hello eforth!!
    --> 錯了, 每個 .py 檔都自己 import re, import pdb 反而是對的, see:
        https://stackoverflow.com/questions/8957859/python-child-cannot-use-a-module-the-parent-imported
        ... Generally if you're doing simple obvious things like importing a standard module, 
        you should do it the simple and obvious way......
[x] reproduce the problem:
        import peforth as vm
        vm.dictate('code test end-code') # Try this first
        vm.words['forth']    
    這樣是成功的,但是進入 forth command line 之後, 同樣的工作... 還是成功的。
    --> 改試 vm.dictate('code test3 print("hello test3!!") end-code')
        >>> vm.execute('test3') --> hello test3!!  很成功
    --> 進 forth command line
            >>> vm.peforth()
            OK code test4 print("hello test4") end-code
            OK test4
            hello test4
            OK
        還是很成功
    --> 好像要出過 error e.g. word unknown 之類才能複製問題
        >>> code test5 end-code
          File "<stdin>", line 1
            code test5 end-code
                     ^
        SyntaxError: invalid syntax
        >>>
        的確是這樣!!! now I've got the SRP
    --> 似乎是 w.xt(w) 執行 end-code 時出問題, 檢查此時的 end-code 
        RI, outer() 裡面分辨 token 是否 [int, float] 用 eval(token) 會有 exception
        必須要用 try - except 處理才行。 --> Fixed !!!
        
        
        
        